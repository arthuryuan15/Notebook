# 多线程

Day19-day20

## 1 进程和线程的区别

【1】程序： 

​		平时我们编写的代码，就是程序（通过各种语言编写） 

【2】进程： 

​		程序一旦运行起来，就要在内存中分配空间，产生了一个进程。 

【3】线程： 

​		进程中的执行单元。 

画图：



![Screen Shot 2019-09-29 at 9.31.37 PM](https://tva1.sinaimg.cn/large/008eGmZEly1gosq5qr68tj31j40hwq8j.jpg)



![Screen Shot 2019-09-29 at 9.31.53 PM](https://tva1.sinaimg.cn/large/008eGmZEly1gosq6bksmfj31vy0tg4qp.jpg)



## 2 线程创建的三种方式



![Screen Shot 2019-09-29 at 9.35.00 PM](https://tva1.sinaimg.cn/large/008eGmZEly1gosq6kh4ntj31mg0pkgrh.jpg)



### 2.1 继承Thread类

```java
package com.sxt.test1;

// TestThread继承了Thread，它就具备了多线程的能力
// 有个多线程的能力，就可以和其他线程争抢CPU资源
// TestThread线程下的具体的对象就是线程对象

public class TestThread extends Thread{

    // 一会要去争抢资源了
    // 这个线程做的事儿就是打印10个数，这个线程的任务写到run方法

    @Override
    public void run() {
        for(int i = 0; i < 50; i++){
            System.out.println(this.getName() + i);
        }
    }
}
```

```java
public class Test {
  
    //在我的程序中现在有三个线程：1.主线程  2.子线程tt  3.垃圾回收机制（忽略不计）
  
    public static void main(String[] args) {//主线程
        for(int i=1;i<=10;i++){
            System.out.println("main方法（1）----------:"+i);
        }
      
        //创建一个子线程：TestThread的对象：
        TestThread tt=new TestThread();//子线程
        //tt.run();//想要执行子线程的任务，这里相当于调了一个普通对象的run方法
        tt.start();// 启动这个线程，要有启动这个线程，才会有争抢资源的效果，tt是Thread的方法
        
      	//start方法是父类Thread中的方法：
        //使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
        for(int i=1;i<=10;i++){
            System.out.println("main方法（2）----------:"+i);
        }
    }
}
```



【1】利用setName，getName方法：

```java
//TestThread类，继承了Thread，它就具备了多线程的能力
//有个多线程的能力，就可以跟其它的线程争抢CPU资源
//TestThread线程类下的具体的对象就是线程对象。
public class TestThread extends Thread{
    //一会要去争抢资源了，这个线程要做的任务是什么呢？将任务写到run方法中：
    @Override
    public void run() {
        for (int i=1;i<=10;i++){
            System.out.println(this.getName()+i);
        }
    }
}
```



```java
public class Test {
    //在我的程序中现在有三个线程：1.主线程  2.子线程tt  3.垃圾回收机制（忽略不计）
    public static void main(String[] args) {//主线程
        Thread.currentThread().setName("主线程");
        for(int i=1;i<=10;i++){
            System.out.println(Thread.currentThread().getName()+i);
        }
        //创建一个子线程：TestThread的对象：
        TestThread tt=new TestThread();//子线程
        tt.setName("这是第一个子线程：");
        //tt.run();//想要执行子线程的任务
        tt.start();//启动这个线程
        //start方法是父类Thread中的方法：
        //使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
        for(int i=1;i<=10;i++){
            System.out.println(Thread.currentThread().getName()+i);
        }
    }
}
```

【2】利用有参构造器：

```java
//TestThread类，继承了Thread，它就具备了多线程的能力
//有个多线程的能力，就可以跟其它的线程争抢CPU资源
//TestThread线程类下的具体的对象就是线程对象。

public class TestThread extends Thread{
  	
  	// 创建一个有参构造器，一会儿用来设置名字
    public TestThread(String name) {
        super(name);
    }
  
    //一会要去争抢资源了，这个线程要做的任务是什么呢？将任务写到run方法中：
    @Override
    public void run() {
        for (int i=1;i<=10;i++){
            System.out.println(this.getName()+i);
        }
    }
}
```

```java
public class Test {
    //在我的程序中现在有三个线程：1.主线程  2.子线程tt  3.垃圾回收机制（忽略不计）
    public static void main(String[] args) {//主线程
        Thread.currentThread().setName("主线程");
        for(int i=1;i<=10;i++){
            System.out.println(Thread.currentThread().getName()+i);
        }
        //创建一个子线程：TestThread的对象：
        TestThread tt=new TestThread("子线程01111111：");//子线程
        //tt.run();//想要执行子线程的任务
        tt.start();//启动这个线程
        //start方法是父类Thread中的方法：
        //使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
        for(int i=1;i<=10;i++){
            System.out.println(Thread.currentThread().getName()+i);
        }
    }
}
```

【3】例子：龟兔赛跑

```java
package com.sxt.test02;

public class Tortoise extends Thread{ // 乌龟

    // 加一个有参构造器，一会儿用来设置线程的名字
    public Tortoise(String name){
        super(name);
    }
    // 重写run方法
    @Override
    public void run() {
        while(true){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("我是" + this.getName() + "，我在跑，我现在领先了。。。。");
        }
    }
}
```

```java
package com.sxt.test02;

public class Rabbit extends Thread{

    // 加一个有参构造器，一会儿用来设置线程的名字
    public Rabbit(String name){
        super(name);
    }

    @Override
    public void run() {
        while(true){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("我是"+ this.getName() + "，我没有偷懒，我一直在跑。。。。");
        }
    }
}
```



```java
package com.sxt.test02;

public class Test {

    public static void main(String[] args) {
        // 乌龟线程
        Tortoise tt = new Tortoise("乌龟线程");
        tt.start();
        // 兔子线程
        Rabbit rb = new Rabbit("兔子线程");
        rb.start();
    }
}
```

输出：有争抢线程的效果

```
我是兔子线程，我没有偷懒，我一直在跑。。。。
我是兔子线程，我没有偷懒，我一直在跑。。。。
我是乌龟线程，我在跑，我现在领先了。。。。
我是兔子线程，我没有偷懒，我一直在跑。。。。
我是乌龟线程，我在跑，我现在领先了。。。。
我是兔子线程，我没有偷懒，我一直在跑。。。。
我是乌龟线程，我在跑，我现在领先了。。。。
```





【3】例子：买火车牌

![Screen Shot 2019-09-29 at 10.00.54 PM](https://tva1.sinaimg.cn/large/008eGmZEly1goy9rne2p1j31bm0t60v9.jpg)



```java
package com.sxt.test03;

public class BuyTrainTicket extends Thread {
  
    //属性：（不同窗口共享10张票）
    private static int ticketNum=10; 
  	//private int ticketNum = 10; // 没有共享， 创建一个对象，就有10张票，创建了3个对象，就有30张票
    
  	//构造器：设置线程名字，也就是设置窗口的名字：
    public BuyTrainTicket(String name) {
        super(name);
    }
  
    //每个窗口做什么事：写入run方法：
    @Override
    public void run() {
        for(int i=1;i<=100;i++){
            if(ticketNum>0){
                System.out.println("我在"+this.getName()+"买到了从北京到哈尔滨的票,现在票剩余："+(--ticketNum)+"张");
            }
        }
    }
}
```

```java
package com.sxt.test03;

public class Test {
    public static void main(String[] args) {
      
        //有几个线程？三个线程。，每个线程就是一个窗口：
        BuyTrainTicket b1=new BuyTrainTicket("窗口1");
        b1.start();
        BuyTrainTicket b2=new BuyTrainTicket("窗口2");
        b2.start();
        BuyTrainTicket b3=new BuyTrainTicket("窗口3");
        b3.start();
    }
}
```

输出：

```
我在窗口3买到了从北京到哈尔滨的票,现在票剩余：7张
我在窗口3买到了从北京到哈尔滨的票,现在票剩余：6张
我在窗口1买到了从北京到哈尔滨的票,现在票剩余：9张
我在窗口2买到了从北京到哈尔滨的票,现在票剩余：8张
我在窗口1买到了从北京到哈尔滨的票,现在票剩余：4张
我在窗口3买到了从北京到哈尔滨的票,现在票剩余：5张
我在窗口1买到了从北京到哈尔滨的票,现在票剩余：2张
我在窗口2买到了从北京到哈尔滨的票,现在票剩余：3张
我在窗口1买到了从北京到哈尔滨的票,现在票剩余：0张
我在窗口3买到了从北京到哈尔滨的票,现在票剩余：1张
```

注：输出可能有两个7，-1等

### 2.2 实现Runable接口

```java
package com.sxt.test04;

public class TestThread implements Runnable{
    @Override
    public void run() {
        for(int i=1;i<=10;i++){
            System.out.println(Thread.currentThread().getName()+"------:"+i);
        }
    }
}
```



```java
package com.sxt.test04;

public class Test {
    public static void main(String[] args) {//主线程
        //创建子线程：
        TestThread tt=new TestThread();
        Thread t=new Thread(tt,"子线程");//通过构造器将Thread和TestThread进行了关联
        t.start(); 
        for(int i=1;i<=10;i++){
            System.out.println("main----"+i);
        }
    }
}
```

输出：

```
主方法开始执行了
main1
main2
子线程1
main3
子线程2
main4
main5
main6
main7
main8
main9
main10
```

说明：

​	上述有交错出现。

![Screen Shot 2019-09-29 at 10.19.27 PM](https://tva1.sinaimg.cn/large/008eGmZEly1gosq75pvafj31ei0jujwe.jpg)

1. `TestThread tt=new TestThread();
   Thread t=new Thread(tt,"子线程");//通过构造器将Thread和TestThread进行了关联`

   表面上是调用的start方法，但实际上，调用的是TestThread里面的run方法。

2. 通过Thread的有参构造器将Thread和TestThread进行关联。 `Thread t=new Thread(tt,"子线程");`

3. Thread和TestThread共同实现了一个Runable接口

   `public class Thread implements Runnable {}`

   `public class TestThread implements Runnable{)`

4. 上述设计模式是：代理模式

####2.2.1 扩展：静态代理模式

【1】代理：proxy，Agent

【2】代理是什么？

如果直接租给租客，带给她看房子，砍价还价，签合同

最有效率的办法：

​		房东 — 》 中介 —》租客



房东（被代理的人，真实对象）：省事，房东：最关注的租房拿钱！

中介（代理）：在帮助房东完成租房的基础上，可以提供一切服务，来简化房东的经历

接口：

```java
package com.sxt.test05;

/*
 * 真实对象和代理 必须按照同一套标准来合作
 * */

public interface Rent { // 租房
    // 你拿钱我给房：
    Object rentHouse(double money);
}
```

房东：

```java
package com.sxt.test05;

/*
* 房东
* */

public class Host implements Rent{
    // 房东的名字：
    private String name;

    // 房屋的地址：
    private String address;

    public Host(String name, String address){
        this.name = name;
        this.address = address;
    }

    public String getAddress(){
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public Object rentHouse(double money){
        System.out.println("房东在租房，你交了"+money+"元的房租");
        return new Object();
    }
}
```

没有中介直接找房东的租客:

```java
package com.sxt.test05;

public class Customer { // 租客

    public static void main(String[] args) {
        Host host = new Host("张三", "回龙观地铁口南400m");
        Object o = host.rentHouse(2500);
        System.out.println(o);

    }
}
```

这个代码对租客和对房东都没有保障，不好，引入中介

```java
package com.sxt.test05;

public class HouseProxy implements Rent{ // 中介

    // 中介为房东服务：
    private Host host;

    public HouseProxy(Host host){ // 中介和房东通过构造器连接在一起
        this.host = host; // 为了和上面的host区分，加上this.

    }
    @Override
    public Object rentHouse(double money) {

        lookhouse();
        bargin();
        Object o = host.rentHouse(money); // 钱通过中介给房东，房子也是房东给你
        maintain();
        return o;
    }

    private void lookhouse() {
        System.out.println("随时看房");
}

    private void bargin(){
        System.out.println("尽力帮你花最少的钱");
    }

    private void maintain(){
        System.out.println("每三周打扫一下卫生");
    }
}
```

找中介的租客:

```java
public class Customer { // 租客

    public static void main(String[] args) {
        // 跟中介接触
        HouseProxy hp = new HouseProxy(new Host("张三", "定海园")); // 告诉中介我要租哪个房子
        Object o  = hp.rentHouse(3000); // 表面钱给中介了，你走到里面去，实际这个钱又给了房东了
        System.out.println(o);
    }
}
```



![Screen Shot 2019-09-30 at 12.12.20 AM](https://tva1.sinaimg.cn/large/008eGmZEly1gosq7aynbzj31oi0qk1ef.jpg)

总结：代理：zhaoshanshan   被代理：家聪聪，刘芳 

关联：利用代理的有参构造器   

代理中方法要比被代理的方法 多！ 



####  2.2.2 龟兔赛跑

```java
package com.stx.test06;

public class Tortoise implements Runnable{

    @Override
    public void run() {
        while (true){
            System.out.println(Thread.currentThread().getName()+"一直跑");
        }
    }
}
```



```java
package com.stx.test06;

import java.text.RuleBasedCollator;

public class Test {

    public static void main(String[] args) {
        // 乌龟
        Tortoise tt = new Tortoise(); // 创建一个线程对象
        Thread t = new Thread(tt); // 如果想调用Tortoise这个线程对象，要将改线程对象传入Thread
        t.setName("乌龟");
        t.start();

        // 兔子 ：参数为匿名内部类
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    System.out.println("兔子一直在跑");
                }
            }
        });
        t2.start();
    }
}
```

输出

```
兔子一直在跑
兔子一直在跑
兔子一直在跑
乌龟一直跑
乌龟一直跑
乌龟一直跑
乌龟一直跑
乌龟一直跑
乌龟一直跑
乌龟一直跑
```

兔子乌龟交替进行

#### 2.2.3 买火车票

```java
package com.sxt.test07;

public class BuyTrainTicket implements Runnable{

    private int ticketNum = 10; // 注意：这里没有加static

    //每个窗口做什么事：写入run方法：
    @Override
    public void run() {
        // 加入睡眠为了模拟线程之间的切换
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        for(int i=1;i<=100;i++){
            if(ticketNum>0){
                System.out.println("我在"+Thread.currentThread().getName()+"买到了第"+(ticketNum--)+"张火车票"+"剩余"+(--ticketNum)+"张火车票");
            }
        }
    }
}
```

```java
package com.sxt.test07;

public class Test {
    public static void main(String[] args) {

        //有几个线程？三个线程。，每个线程就是一个窗口
        // 窗口1
        BuyTrainTicket b1 = new BuyTrainTicket();
        new Thread(b1, "窗口1").start();
       /* // 同下
        Thread tt = new Thread(b1);
        tt.start();*/

        // 窗口2
        BuyTrainTicket b2 = new BuyTrainTicket();
        new Thread(b2, "窗口2").start();
        // 窗口3
        BuyTrainTicket b3 = new BuyTrainTicket();
        new Thread(b3, "窗口3").start();
    }
}
```



注：如果共享一个线程对象，则该线程对象不需要加static修饰



### 2.3 实现Callable接口

第一种和第二种的run方法的缺点：

```java
public class Test implements  Runnable{
    @Override
    public void run() {        
    }
}
```

缺点1：这个方法没有返回值。 	

缺点2：不能抛出异常 



所以基于上面两个缺点，引入了方式3： 



方式3：JDK1.5以后为了解决上述缺点： 

​	好处：call方法可以有返回值，还可以处理异常 

​	缺点：线程创建比较麻烦  

 	get方法是一个阻塞方法，什么时候线程代码执行完毕才会将返回值做一个获取。 	

```java
package com.sxt.test08;

import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class RundomNum implements Callable<Integer>{//产生随机数的线程
  
    //对于这个call方法来说，有返回值，返回值的类型跟泛型是一致的，并且对于这个方法是可以抛出异常的
    @Override
    public Integer call() /*throws Exception*/ {
        System.out.println("--------");
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return new Random().nextInt(10);//生成10以内的随机数
    }
  
    public static void main(String[] args) throws ExecutionException, InterruptedException {
      
        //创建线程对象：
        RundomNum rn=new RundomNum();
        FutureTask ft=new FutureTask(rn);
        Thread t=new Thread(ft);
        t.start();
      
        //获取线程执行的结果：
        // Thread.sleep(3000);是一个阻塞的方法
        System.out.println("当前线程是否在完成："+ft.isDone());
        Integer i=(Integer)(ft.get());//接收call方法的返回值的。
        System.out.println(i);
        System.out.println("当前线程是否在完成："+ft.isDone());
    }
}
```



###2.4 总结

第一种和第二种哪个好？ 

​	java中只有单继承，所以用第二种实现接口的方式，还可以继承其他的类。

第三种好处： 

（1）call方法有返回值 

（2）可以抛出异常 



## 3 线程的生命周期

以下内容来自《java多线程编程实战指南》

![Screen Shot 2019-10-11 at 11.42.21 PM](https://tva1.sinaimg.cn/large/008eGmZEly1gosq7hyqvwj30u00v3n7h.jpg)



![Screen Shot 2019-10-11 at 11.56.01 PM](https://tva1.sinaimg.cn/large/008eGmZEly1gosq7oadzij30u00uqkjl.jpg)



### 3.1 线程之间的通信方式

1. volatile

   volatile有两大特性，一是可见性，二是有序性，禁止指令重排序，其中可见性就是可以让线程之间进行通信。

2. 等待/通知机制

   等待通知机制是基于wait和notify方法来实现的，在一个线程内调用该线程锁对象的wait方法，线程将进入等待队列进行等待直到被通知或者被唤醒。



## 4 线程控制的常用方法

### 4.1 getPriority()和setPriority()

getPriority()

```java
public class Tortoise extends Thread{//乌龟
    //加一个有参构造器，一会用来设置线程的名字：
    public Tortoise(String name) {
        super(name);
    }
    //重写run方法：
    @Override
    public void run() {
        while(true){
            System.out.println("我是"+this.getName()+"，我在跑，我现在领先了。。乌龟的优先级级别："+this.getPriority());
        }
    }
}
```



```java
public class Rabbit extends Thread {//兔子：
    //用来设置线程名字的
    public Rabbit(String name) {
        super(name);
    }
    //重写run方法：
    @Override
    public void run() {
        while(true){
            System.out.println("我是"+this.getName()+"，我没有偷懒，我也在跑。。。兔子的优先级别："+this.getPriority());
        }
    }
}
```

setPriority()

```java
public class Test {
    public static void main(String[] args) {
        //乌龟线程：
        Tortoise tt=new Tortoise("乌龟线程：");
        tt.setPriority(9);
        tt.start();
        //兔子线程：
        Rabbit rb=new Rabbit("兔子线程");
        rb.setPriority(1);
        rb.start();
    }
}
```



【1】线程的默认的优先级别都是5 

​		其实优先级别：从1-10  从低--》高： 

​		哪个线程的优先级别高，就证明这个线程被优先调度的概率大。

### 4.2 join() 

join方法：当A线程调用线程B的join方法，那么A线程的运行被暂停，直到B线程运行结束。----"半路杀出个程咬金" 

注意：必须先start，再join才有效。 

```java
public class TestThread extends Thread {
  
    @Override
    public void run() {
        for(int i=1;i<=10;i++){
            System.out.println(this.getName()+"---------"+i);
        }
    }
  
    public static void main(String[] args) throws InterruptedException {
        for(int i=1;i<=10;i++){
            if(i==6){
                TestThread tt=new TestThread();
                tt.start();
                tt.join();//这里调了一个方法，"半路杀出个程咬金"
            }
            System.out.println(Thread.currentThread().getName()+"-----"+i);
        }
    }
  
}
```



### 4.3 sleep()

睡眠： 

Thread.sleep(3000);//遇到这个方法，程序就被阻塞 

//什么时候“睡完了”，这个阻塞就结束了 

sleep()方法导致了程序暂停，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。

```java
public class Test {
    public static void main(String[] args) {
      
        //裁判：喊： 3.。2  。。。1
        for(int i=3;i>=1;i--){
            System.out.println(i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //乌龟线程：
        Tortoise tt=new Tortoise("乌龟线程：");
        tt.setPriority(9);
        tt.start();
        //兔子线程：
        Rabbit rb=new Rabbit("兔子线程");
        rb.setPriority(1);
        rb.start();
    }
}
```



```java
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
public class Test {
    public static void main(String[] args) {
        //5.格式化提到while循环之外：
        DateFormat df=new SimpleDateFormat("HH:mm:ss");
        //3.加入死循环，让时间一直显示：
        while(true){
            //实现一个秒表：
            //1.获取当前时间：
            Date d=new Date();
            //2.将时间按照我想要展现的格式展现：进行日期的格式化：
            String strDate=df.format(d);
            System.out.println(strDate);
            //4.停顿一秒：
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```



### 4.4 yield()

yield：暂停当前线程，从runing 进入ready状态（不是阻塞，是就绪），进入到就绪状态以后等着CPU的调度、

```java
public class TestThread extends Thread {
    public TestThread(String name) {
        super(name);
    }
    @Override
    public void run() {
        for(int i=1;i<=10;i++){
            System.out.println(this.getName()+"---"+i);
            if(i==6){
                Thread.yield();
                //yield：暂停当前线程，使线程进入到就绪状态（不是阻塞，是就绪），进入到就绪状态以后等着CPU的调度，
可能立马被调用，也可能等着被调用。
            }
        }
    }
    public static void main(String[] args) {
        //创建一个线程
        TestThread t1=new TestThread("线程1");
        t1.start();
        //创建一个线程
        TestThread t2=new TestThread("线程2");
        t2.start();
    }
}
```



### 4.5 setDaemon()

设置伴随线程； 

​		皇上 ---》陪葬----》妃子 

​		main主线程（前台线程）---》伴随线程（后台线程）----》DemoThread 

​		说明：main()函数即主函数，是一个前台线程，前台进程是程序中必须执行完成的，而后台线程则是java中所有前台结束后结束，不管有没有完成，后台线程主要用与内存分配等方面。

​		但是在主线程结束以后，DemoThread  “垂死挣扎”了一下，趁这个时间赶紧再执行一点代码

```java
public class DemoThread extends Thread{
  
    @Override
    public void run() {
        for(int i=1;i<=1000;i++){
            System.out.println(this.getName()+"----"+i);
        }
    }
  
    public static void main(String[] args) {
      
        //子线程创建+启动：
        DemoThread dt=new DemoThread();
        dt.setName("子线程");
      
        //将子线程设置为伴随线程：(主线程死了，让子线程也去死了，但是不能控制，会挣扎一下)
        dt.setDaemon(true);
        dt.start();
        for(int i=1;i<=10;i++){
            System.out.println("main-----"+i);
        }
    }
}
```

### 4.6 stop()

```java
public class Test {
    public static void main(String[] args) {
        for(int i=1;i<=100;i++){
            if(i==6){
                Thread.currentThread().stop(); // 直接把线程干掉
            }
            System.out.println(i);
        }
    }
}
```



### 4.7 threadLocal

**ThreadLocal设计的目的就是为了能够在当前线程中有属于自己的变量，并不是为了解决并发或者共享变量的问题**

ThreadLocal提供了线程的局部变量，每个线程都可以通过`set()`和`get()`来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，**实现了线程的数据隔离**。



## 5 线程安全问题

【1】ticketNum--可能出现的情况： 

​	（1）两个10或者三个10：

```java 
我在窗口3买到了第10张火车票
我在窗口2买到了第10张火车票
我在窗口1买到了第10张火车票
我在窗口2买到了第8张火车票
我在窗口3买到了第9张火车票
我在窗口2买到了第6张火车票
我在窗口1买到了第7张火车票
我在窗口2买到了第4张火车票
我在窗口3买到了第5张火车票
我在窗口2买到了第2张火车票
我在窗口1买到了第3张火车票
我在窗口3买到了第1张火车票
```

![Screen Shot 2019-09-30 at 8.52.13 AM](https://tva1.sinaimg.cn/large/008eGmZEly1gosq7wgp44j31s00imdoc.jpg)

​	说明：

1. `ticketNum—`实际上是有两步tickNum赋值和tickNum-1
2. 线程1还有减1就被线程2抢去了，所以线程2一开始输出也是10，同理还没有`--`的时候被线程3抢了资源，线程3输出也是10
3. 线程3执行 `--`操作，此时线程3剩余9张票 ，然后落到线程1头上开始` - -`变成只有8张票，落到线程2上只有7张票。

（2）出现0，-1，-2.。。

![Screen Shot 2019-09-30 at 8.53.19 AM](https://tva1.sinaimg.cn/large/008eGmZEly1gosq81j3lxj31wm0m80zp.jpg)

说明：

1. 现在共享的票就剩一张了，
2. 线程1进来了， 买了第1张火车票，还没减减就被线程2抢去了
3. 然后进到线程2，此时还是还有一张火车票，线程2执行到“我在口2买，买到了第。。。 ”，还没等打完呢，刚带了一个第，就又被线程1抢去了，然后执行减减，现在的票就剩0张了，然后再被线程2了抢去了。
4. 继续输出“第后面的车票”，此时打印第0张车票，还没等减减呢，被线程3抢去了
5. 我在窗口3，买到了第。。。还没等执行了，又被线程2抢去了，此时线程2开始执行减1操作
6. 然后线程3又把资源抢去了，此时打印第-1张车票。 
7. 线程1和线程2和线程3都是在大于零的时候进来的。



【2】--ticketNum

​	出现两个9

![image_30168](https://tva1.sinaimg.cn/large/008eGmZEly1gosq864pb4j30zr08naa6.jpg)

说明：

1. `--ticketNum`:先减1，减完1之后再将ticketNum输出

2. 两个CPU同时执行线程1和线程2同时在票数等于10的时候进来，同步减1，同时输出9

原因： 

​		就是因为多个线程在争抢资源

解决： 

​		在我的程序中加入--“锁”---->加同步----》同步监视器 （锁、同步、同步监视器都是指一个东西）

注：

​		原子性操作没有必要加同步。

​		原子性操作：最小的操作单元，比如i=1，就是一个原子性操作，这个过程只涉及一个赋值操作。又如i++就不是一个原子操作，它相当于语句i=i+1；这里包括读取i，i+1，结果写入内存三个操作单元。

###5.1 加锁

​		java平台中的锁包括内部锁（Intrinsic Lock）和显示锁（Explicit Lock），内部锁是通过synchronized关键字实现的，显示锁是通过java.concurent.locks.Lock接口的实现类（如java.concurrent.locks.ReentrantLock）实现的。

####5.1.1 同步代码块 

​	synchronized (this){}

```java
package com.sxt.test07;

public class BuyTrainTicket implements Runnable{

    private int ticketNum = 10; // 注意：这里没有加static

    //每个窗口做什么事：写入run方法：
    @Override
    public void run() {
        for(int i=1;i<=100;i++){
            synchronized (this){ // 锁：（）中的内容：this 相当于程序的一把锁
                if(ticketNum>0){
                    try {
                        Thread.sleep(1100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    //System.out.println("我在"+Thread.currentThread().getName()+"买到了第"+(ticketNum--)+"张火车票"+"剩余"+(--ticketNum)+"张火车票");
                    System.out.println("我在"+Thread.currentThread().getName()+"买到了第"+(ticketNum--)+"张火车票");
                }
            }
        }
    }
}
```

底层原理：

```java
package src.com.sxt;

public class SynchronizedDemo {

    public void mothod(){
        synchronized (this){
            System.out.println("synchronized 代码块");
        }
    }
}
```

`javac SynchronizedDemo.java` 

`Javap -c -s -v -l SynchronizedDemo.class  `

 ```java
public void mothod();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: dup
         2: astore_1
         3: monitorenter
         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         7: ldc           #3                  // String synchronized 代码块
         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        12: aload_1
        13: monitorexit
        14: goto          22
        17: astore_2
        18: aload_1
        19: monitorexit
        20: aload_2
        21: athrow
        22: return
      Exception table:
         from    to  target type
             4    14    17   any
            17    20    17   any
      LineNumberTable:
        line 6: 0
        line 7: 4
        line 8: 12
        line 9: 22
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 17
          locals = [ class src/com/sxt/SynchronizedDemo, class java/lang/Object ]
          stack = [ class java/lang/Throwable ]
        frame_type = 250 /* chop */
          offset_delta = 4
}
 ```

说明：

1. synchronized 同步代码块的实现使用的是`3: monitorenter`和`19: monitorexit`指令，其中monitorenter指令指向同步代码块的开始，monitorexit指令指向同步代码块的结束位置。

2. 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor

   (monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取 锁的，也是为什么Java中任意对象可以作为锁的原因)

    的持有权.

3. 当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当 前线程就要阻塞等待，直到锁被另外一个线程释放为止。

补充：

​	Java对象保存在内存中时，由以下三部分组成：

1. 对象头
	(1) Mark Word (记录了对象和锁有关的信息)
	(2) 指向类的指针
	(3) 数组长度
2. 实例对象
3. 对齐填充字节



#### 5.1.2 修饰方法 

public synchronized void buyTicket(){}

```java
package com.sxt.test07;

public class BuyTrainTicket1 implements Runnable{

    private int ticketNum = 10; // 注意：这里没有加static

    //每个窗口做什么事：写入run方法：
    @Override
    public void run() {
        for(int i=1;i<=100;i++) {
            BuyTicket();
        }
    }
		
  	//同步方法谁是锁？  锁的是this，谁调用方法就把谁锁了。
    public synchronized void BuyTicket(){
        if(ticketNum>0){
            try {
                Thread.sleep(1100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //System.out.println("我在"+Thread.currentThread().getName()+"买到了第"+(ticketNum--)+"张火车票"+"剩余"+(--ticketNum)+"张火车票");
            System.out.println("我在"+Thread.currentThread().getName()+"买到了第"+(ticketNum--)+"张火车票");
        }
    }
}
```



底层原理：

```java
package src.com.sxt;

public class SynchronizedDemo2 {

    public synchronized void method(){
        System.out.println("synchronized 方法");
    }
}
```

`javac SynchronizedDemo2.java`

`javap -c -s -v -l SynchronizedDemo2.class`

```java
{
  public src.com.sxt.SynchronizedDemo2();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0

  public synchronized void method();
    descriptor: ()V
    flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #3                  // String synchronized 方法
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 6: 0
        line 7: 8
}
```

说明:

1. synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来 辨别一个方法是否声明为同步方法，从而执行相应的同步调用。



加了同步，代码的执行过程是什么样的？ 

​	线程1：进入到run方法中，看到程序中有锁，但是没有锁住，然后它将这个锁锁住。 

​	其他的线程可以进来，但是看到锁被锁住了，只能等着， 

​	等到什么时候啊？等到线程1完事了，将锁进行释放，释放完了之后其余的线程就可以将这个锁抢过去了，然后谁抢到谁再加上锁。 

--------》 

另一个火车票的代码： 

```java
package com.sxt.test03;

public class BuyTrainTicket1 extends Thread {
    //属性：（不同窗口共享10张票）
    private static int ticketNum = 10;
    //private int ticketNum = 10; // 没有共享， 创建一个对象，就有10张票，创建了3个对象，就有30张票
    //构造器：设置线程名字：设置窗口的名字：
    public BuyTrainTicket1(String name) {
        super(name);
    }

    //每个窗口做什么事：写入run方法：
    @Override
    public void run() {
        for(int i=1;i<=100;i++){
            // 如果写this代表每个对象带一把自己的锁，BuyTrainTicket1.class获取类的字节码信息，对于一个类型来说，字节码信息只有一个，只能用引用数据类型
            synchronized (BuyTrainTicket1.class){
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if(ticketNum>0){
                    System.out.println("我在"+this.getName()+"买到了从北京到哈尔滨的票,现在票剩余："+(--ticketNum)+"张");
                }
            }

        }
    }
}
```



总结： 

​		多线程在争抢资源，就要实现线程的同步（就要进行加锁）， 

​		并且这个锁必须是共享的，必须是唯一的。 

​		咱们的锁一般都是引用数据类型的。 

​		目的：解决了线程安全问题。 



### 5.2 习题

举例：

​	银行卡：主卡 和 副卡  

​	男主人  女主人---》主卡 和 副卡 

```java
public class AccoutThread implements Runnable{
    //共享账号：
    private Account ac=new Account();
    @Override
    public void run() {
      
      // 重新复习：用代码块的方式加锁
       /*synchronized (this){
           if(ac.getBalance()>=400){
               ac.getMoney(300);
               System.out.println(Thread.currentThread().getName()+"在取款，取款后余额为："+ac.getBalance());
           }else{
               System.out.println(Thread.currentThread().getName()+"在取款，但是余额不足400，取款失败");
           }
       }*/
        getM();
    }
  	// 重新复习：用同步方法加锁
    public synchronized  void getM(){
        if(ac.getBalance()>=400){
            ac.getMoney(300);
            System.out.println(Thread.currentThread().getName()+"在取款，取款后余额为："+ac.getBalance());
        }else{
            System.out.println(Thread.currentThread().getName()+"在取款，但是余额不足400，取款失败");
        }
    }
}
```



```java
public class Account {
    //共享钱：
    int money=600;
    //取钱
    public void getMoney(int money){
        this.money-=money;//this.money=this.money-money
    }
    //得到余额
    public int getBalance(){
        return money;
    }
}
```



```java
public class Test {
    public static void main(String[] args) {
        AccoutThread ac=new AccoutThread();
        new Thread(ac,"男主人").start();
        new Thread(ac,"女主人").start();
    }
}
```



### 5.3 线程同步的缺点

【1】 线程同步的问题

​		线程安全，效率低 

​		线程不安全，效率高 

【2】可能造成死锁：

```java
// 经典死锁方法
public class TestDeadLock implements Runnable {
    public int flag = 1;
    static Object o1 = new Object(),o2 = new Object();
        
    public void run(){
        System.out.println("flag=" + flag);
        // 当flag==1锁住o1
        if (flag == 1) {
            synchronized (o1) {
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                // 只要锁住o2就完成
              	// 但是这段代码的执行结束要靠o2，o1说：只要把o2释放出来，立马把o1的锁释放出来
                synchronized (o2) {
                    System.out.println("2");
                }
            }
        }
        // 如果flag==0锁住o2
        if (flag == 0) {
            synchronized (o2) {
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                // 只要锁住o1就完成
              	// 这里想锁o1，但是被上面的锁住了，，o2说：只要把o1释放出来，立马把o2的锁释放出来
                synchronized (o1) {
                    System.out.println("3");
                }
            }
        }
    }
        
        
    public static void main(String[] args) {
        // 实例2个线程类
        TestDeadLock td1 = new TestDeadLock();
        TestDeadLock td2 = new TestDeadLock();
        td1.flag = 1;
        td2.flag = 0;
        // 开启2个线程
        Thread t1 = new Thread(td1);
        Thread t2 = new Thread(td2);
        t1.start();
        t2.start();
    }
}
```



疑问1： 

（1） `static Object o1 = new Object(),o2 = new Object();`static去掉，还会死锁吗？

​		不会 。因为`TestDeadLock td1 = new TestDeadLock();``TestDeadLock td2 = new TestDeadLock();`创建了两个线程对象，如果加了static这个td1(o1)和td2(o2)才是唯一的，因为放到静态区域里面去了。如果不加static，第一个线程有o1，第二个线程也有o1，这样只是各自锁自己的了

（2）如何解决死锁？ 

```java
        if (flag == 1) {
            synchronized (o1) {
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
          	// 只要一个锁里面不加锁就行 
            synchronized (o2) {
            	System.out.println("2");
            }
        }
```

### 5.4 Lock锁



Lock锁： 

​        JDK1.5后新增功能， 

​        与采用synchronized相比，lock可提供多种锁方案，更灵活  

​        注意：如果同步代码有异常，要将unlock()写入finally语句块 

   

​		ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义， 

​        但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。 	

​        此外，它还提供了在激烈争用情况下更佳的性能。 	 



Lock和synchronized的区别 

​        1.Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁 

​        2.Lock只有代码块锁，synchronized有代码块锁和方法锁 

​        3.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）



​        优先使用顺序： 

​        Lock----同步代码块（已经进入了方法体，分配了相应资源）----同步方法（在方法体之外） 

 

```java
package com.sxt.test07;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class BuyTrainTicket implements Runnable {
    private int ticketNum=10;
  
    //相当于"买来一把锁":
    Lock lock = new ReentrantLock();//多态 Lock是一个接口，不是直接new，要new Lock下面的一个实现类
  
    @Override
    public void run() {
        for(int i=1;i<=100;i++){
          
            //打开锁
            lock.lock();
            try{ // 用一个异常捕获
                if(ticketNum>0){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("我在"+Thread.currentThread().getName()+"买到了火车票，剩余"+(--ticketNum)+"张");
                }
            }catch(Exception ex){
                ex.printStackTrace();
            }finally {

             //关闭锁
             lock.unlock();
            }
        }
    }
}
```

说明： //打开锁
            lock.lock();

​			//关闭锁

​			lock.unlock();

### 5.5 volatile

​		读取一个volatile变量总是意味着（通过高速缓存进行的）读内存操作，而不是从寄存器中读取。

### 5.6 悲观锁 乐观锁

悲观锁：

1. 总是假设最坏的情况，每次拿数据就会被别人认为会修改，所以每次在拿数据的时候就会加上锁，这样别人想拿这个数据就会阻塞其他拿到锁。
2. java中synchronized 和 reentrantlock等独占锁就是悲观思想的实现。

乐观锁：

1. 总是假设最好的情况，每次拿数据都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用CAS算法实现。
2. CAS实现过程：
   1. cas即compare and swap（比较和交换）。是一种无锁算法。
   2. cas包括三个参数：**当前内存值V、旧的预期值old value**、**即将更新的值new value**，当且仅当预期值old value和内存值V相同时，将内存值修改为new value并返回true，否则什么都不做，并返回false。
   3. CAS 有效地说明了“ 我认为位置 V 应该包含值 old value，如果真的包含old value值，则将 new value放到这个位置，否则，不要更改该位置，只告诉我这个位置现在的值(A)即可。
3. AtomicInteger类



### 5.7 分布式锁

分布式锁 使用redis



### 5.6 扩展：小故事



## 6 线程组

​		用户创建的所有线程都属于指定*线程组*，如果没有显示指定属于哪个*线程组*，那么该线程就属于默认*线程组*（即main*线程组*）

```java
package com.sxt.test12;
·
public class TestThread extends Thread{

    @Override
    public void run() {
        for(int i = 1; i <= 10; i++){
            System.out.println(i);
        }
    }

    // 空构造器
    public TestThread(){

    }

    // 设置线程名字
    public TestThread(String name) {
        super(name);
    }

    // 设置线程
    // 两个参数：第一个参数设置线程所在的线程组，第二个参数：设置线程的名字的
    public TestThread(ThreadGroup group, String name) {
        super(group, name);
    }

    public static void main(String[] args) {
        TestThread tt = new TestThread();
        tt.setName("这是一个线程名字");
        System.out.println(tt.toString());
        // Thread[Thread-0,5,main] --> 线程名字，优先级别，线程组名字：
        System.out.println(tt.getThreadGroup().getName()); // main
        System.out.println(tt.getThreadGroup().getParent().getName()); // 上层组
//        System.out.println(tt.getThreadGroup().getParent().getParent().getParent());// null

        // 创建一个线程组
        ThreadGroup tg = new ThreadGroup("我的线程组哈哈哈哈");
        System.out.println(tg.getName());

        TestThread t1 = new TestThread(tg, "线程1");
        TestThread t2 = new TestThread(tg, "线程2");
        TestThread t3 = new TestThread("线程3");

        System.out.println(t1.getThreadGroup().getName());

        t1.start(); // 如果想让tg线程组下面的线程t1和t2显示的话，启动之后才能生效
        t2.start();
        System.out.println("-----------------");
        tg.list();
    }
}
```



## 7 线程组之间的通信

应用场景：生产者和消费者问题 

​		假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费 

​		如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止 

​		如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止 

![Screen Shot 2019-09-30 at 9.51.09 PM](https://tva1.sinaimg.cn/large/008eGmZEly1goy9ro4nj4j31ru0dkjt3.jpg)

### 7.1 分解1：出现问题的情况

```java
public class Product {//商品
    //属性：
    //品牌
    private String brand;
    //名字
    private String name;
    //提供setget方法：
    public String getBrand() {
        return brand;
    }
    public void setBrand(String brand) {
        this.brand = brand;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
```

```java
public class ProducerThread extends Thread {//生产者线程
    //共享商品：
    private Product p;
    public ProducerThread(Product p){
        this.p=p;
    }
    //重写run方法：
    @Override
    public void run() {
        for(int i=1;i<=10;i++){
            if(i%2==0){
                //费列罗巧克力：
                p.setBrand("费列罗");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                p.setName("巧克力");
            }else{
                p.setBrand("哈尔滨");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                p.setName("啤酒");
            }
            //将信息打印：
            System.out.println("生产者生产了："+p.getBrand()+"----"+p.getName());
        }
    }
}
```

```java
public class CustomerThread extends Thread {//消费者线程
    private Product p;
    public CustomerThread(Product p){
        this.p=p;
    }
    //重写run方法：
    @Override
    public void run() {
        for (int i=1;i<=10;i++){
            System.out.println("消费者消费，消费了："+p.getBrand()+"----"+p.getName());
        }
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        //创建一个共享商品：
        Product p=new Product();
        //创建生产者和消费者线程：
        CustomerThread ct=new CustomerThread(p);
        ProducerThread pt=new ProducerThread(p);
        pt.start();
        ct.start();
    }
}
```



代码出现的问题： 

（1）没有交替生产和消费 

​		正常效果生产一个消费一个，但是现在生产好几个，消费好几个。 

（2）打印数据错乱： 

​		哈尔滨 null   

​		哈尔滨 巧克力 

​		费列罗啤酒 



### 7.2 分解2：加锁

【1】加锁：利用同步代码块

```java
public class ProducerThread extends Thread {//生产者线程
    //共享商品：
    private Product p;
    public ProducerThread(Product p){
        this.p=p;
    }
    //重写run方法：
    @Override
    public void run() {
        for(int i=1;i<=10;i++){
            synchronized (p){ // 加上 synchronized (p) 
                if(i%2==0){
                    //费列罗巧克力：
                    p.setBrand("费列罗");
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    p.setName("巧克力");
                }else{
                    p.setBrand("哈尔滨");
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    p.setName("啤酒");
                }
                //将信息打印：
                System.out.println("生产者生产了："+p.getBrand()+"----"+p.getName());
            }
        }
    }
}
```



```java
public class CustomerThread extends Thread {//消费者线程
    private Product p;
    public CustomerThread(Product p){
        this.p=p;
    }
    //重写run方法：
    @Override
    public void run() {
        for (int i=1;i<=10;i++){
            synchronized (p){ // synchronized (p)
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("消费者消费，消费了："+p.getBrand()+"----"+p.getName());
            }
        }
    }
}
```



【2】加锁：同步方法

```java
public class Product {//商品
  
    //属性：
    //品牌
    private String brand;
    //名字
    private String name;
    //提供setget方法：
    public String getBrand() {
        return brand;
    }
    public void setBrand(String brand) {
        this.brand = brand;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
  
    //生产产品：
    public synchronized void setProduct(String brand,String name){ // 为了锁住商品，所以把锁加在这里
        this.setBrand(brand);
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.setName(name);
      
        //将信息打印：
        System.out.println("生产者生产了："+this.getBrand()+"----"+this.getName());
    }
  
    //消费商品也设一把锁
    public synchronized void getProduct(){ 
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("消费者消费，消费了："+this.getBrand()+"----"+this.getName());
    }
}
```

现在代码中还有的问题：生产和消费并没有交替进行



### 7.3 分解3 方式三：等待唤醒

​		解决生产者和消费者交替出现的问题，设置一个灯![Screen Shot 2019-09-30 at 11.32.20 PM](https://tva1.sinaimg.cn/large/008eGmZEly1gosq8ihzq4j31z00tmn7r.jpg)

```java
public class Product {//商品
    //属性：
    //品牌
    private String brand;
    //名字
    private String name;
  
  	/*
  	*加入一个“灯
  	*/
    boolean flag=false;//最开始这个灯应该是绿色的：false--》没有商品
  
 
    //提供setget方法：
    public String getBrand() {
        return brand;
    }
    public void setBrand(String brand) {
        this.brand = brand;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    //生产产品：
    public synchronized void setProduct(String brand,String name){
      
      
        if(flag==true){//灯是红色：生产者不生产的，等着
            try {
                wait();//Object的方法
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //如果灯是绿色的呢？开始生产商品：
        this.setBrand(brand);
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.setName(name);
        //将信息打印：
        System.out.println("生产者生产了："+this.getBrand()+"----"+this.getName());
        //截止到上面，商品已经生产完了：
        //将灯变成：红色
        flag=true;
        //告诉消费者赶紧来消费：
        notify();//Object类方法
    }
    //消费商品
    public synchronized void getProduct(){
        if(!flag){//flag==false--->如果灯是绿色的：
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
      
      
        //如果灯是红色的：开始消费：
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("消费者消费，消费了："+this.getBrand()+"----"+this.getName());
        //截止到这里，消费结束
      
      
        //灯变成：绿色：
        flag=false;
        //通知生产者赶紧生产：
        notify();
    }
}
```

​	wait()和notify() 相互作用

一个线程因其执行目标动作所需的保护条件(如if)未满足而被暂停的过程就被称为等待(wait()）。

一个线程更新了系统的状态，使得其他线程所需的保护条件得以满足的时候唤醒那些被暂停的线程的过程称为通知（Notify）。



在Java对象中，有两种池

​		锁池--------------------synchronized

​		等待池----------------wait() notify() notifyAll()

如果一个线程调用了某个对象的wait方法，那么该线程进入该对象的等待池（并且已经将锁释放），

如果未来的某一时刻，另外一个线程调用了相同对象的notify方法或者notifyAll方法，那么该等待池中的线程就会被唤起，然后进入到对象的锁池里面去获得该对象的锁。

如果获得锁成功后，那么该线程会沿着wait方法之后的路径继续执行，注意是沿着wait方法之后

notifyAll()  ,通知其他的线程（多余两个线程）来抢资源







## 8 线程池

（1）降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 

（2）提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。

（3）提高线程的可管理性。 

*线程池*的好处Java中的*线程池*是运用场景最多的*并发*框架，

* 几乎所有需要**异步**或**并发**执行任务的程序都可以使用**线程池**



### 7.1 队列

队列分类：阻塞队列、非阻塞队列



![Screen Shot 2019-09-30 at 11.52.04 PM](https://tva1.sinaimg.cn/large/008eGmZEly1gosq8stw9oj31g50u0ar5.jpg)

线程池用到的是阻塞队列。

### 7.2 线程池

【1】线程池：装线程的 

【2】作用： 

![Screen Shot 2019-09-30 at 11.55.22 PM](https://tva1.sinaimg.cn/large/008eGmZEly1gosq8xj17aj31su0tewri.jpg)

线程正常状态： 

新生---》就绪---》运行---》死亡 

​       3s            2s      1s    3s 

目的：将运行之前的时间 节省，将运行之后的时间节省---》线程池：减少创建和消亡的时间。 

【3】线程池的原理：

![Screen Shot 2019-09-30 at 11.57.38 PM](https://tva1.sinaimg.cn/large/008eGmZEly1gosq93eni4j31x60u01kx.jpg)

注：核心线程数和最大线程数区别

核心线程数就像是工厂正式工，最大线程数，就是工厂临时工作量加大，请了一批临时工，临时工加正式工的和就是最大线程数，等这批任务结束后，临时工要辞退的，而正式工留下。

【4】代码层面证明：

```java
public class Test {
    public static void main(String[] args) {
        //创建一个线程池：
        ThreadPoolExecutor t
        =new ThreadPoolExecutor//利用有参构造器创建对象
        (1,//设置核心线程数为1
        2,//最大线程数2
        3, TimeUnit.MILLISECONDS,//3毫秒，新创建的线程等任务最多等3毫秒，如果3毫秒内没有等到，这个新创建的线程就自动销毁
         new LinkedBlockingDeque<>(3));//利用阻塞队列，长度为3：
        //执行任务：
        //放入第1个任务：
        t.execute(new TestThread());
        //放入第2个任务：---》在核心线程忙着的时候，放入队列，
        t.execute(new TestThread());
        //放入第3个任务：---》在核心线程忙着的时候，放入队列，
        t.execute(new TestThread());
        //放入第4个任务：---》在核心线程忙着的时候，放入队列，
        t.execute(new TestThread());
        //放入第5个任务：---》这个时候队列满了，创建新的线程来执行第5个任务了：
        //并且与核心线程一起分摊任务：
        t.execute(new TestThread());
        //放入第6个任务：报错，拒绝执行任务：RejectedExecutionException:
        t.execute(new TestThread());
        //关闭线程池：
        t.shutdown();
    }
}
```

```java
public class TestThread implements Runnable {
    //这个run方法中的内容就是执行的任务：
    @Override
    public void run() {
        System.out.println("当前执行任务的线程为："+Thread.currentThread().getName());
    }
}
```

### 7.3 内置线程池

JDK1.5之后提供了内置线程池：

【1】可缓存线程池：

```java
public class Test {
    public static void main(String[] args) {
        //可缓存线程：
        ExecutorService es = Executors.newCachedThreadPool();
        //执行任务：
        for(int i=1;i<=100;i++){
            es.execute(new TestThread());
        }
        //关闭：
        es.shutdown();
    }
}
```

最开始没有核心线程，来一个任务，新建一个线程来执行这个任务，当这个任务执行完以后，这个线程继续执行其他的任务，所以在结果中我们发现，线程可以是重复的：

![Screen Shot 2019-10-01 at 12.05.53 AM](https://tva1.sinaimg.cn/large/008eGmZEly1gosq9akuatj31ak0os7u1.jpg)

【2】定长线程池：

```java
public class Test {
    public static void main(String[] args) {
        //定长线程：
        ExecutorService es = Executors.newFixedThreadPool(3);
        //执行任务：
        for(int i=1;i<=100;i++){
            es.execute(new TestThread());
        }
        //关闭：
        es.shutdown();
    }
}
```

从结果可以看出，就一共有三个线程Executors.newFixedThreadPool(3);在执行任务：

【3】定时线程池：

```java
public class Test {
    public static void main(String[] args) {
        //定时线程：
        ScheduledExecutorService ses=Executors.newScheduledThreadPool(3);
        //执行任务：
        for(int i=1;i<=100;i++){
            ses.schedule(new TestThread(),3, TimeUnit.SECONDS);
        }
        //关闭：
        ses.shutdown();
    }
}
```

 	进行延时：延时3秒执行线程 	



【4】单例线程池： 

```java
public class Test {
    public static void main(String[] args) {
        //单例线程：
        ExecutorService es= Executors.newSingleThreadExecutor();
        //执行任务：
        for(int i=1;i<=100;i++){
           es.execute(new TestThread());
        }
        //关闭：
        es.shutdown();
    }
}
```

​		就是由一个线程来执行任务

```java
public class Test {
    public static void main(String[] args) {
        //单例线程：
        ExecutorService es= Executors.newSingleThreadExecutor();
        //执行任务：
        for(int i=1;i<=100;i++){
            //利用匿名内部类的对象传入execute方法也是可以的：
           es.execute(new Runnable() {
               @Override
               public void run() {
                   System.out.println("当前线程为："+Thread.currentThread().getName());
               }
           });
        }
        //关闭：
        es.shutdown();
    }
}
```

